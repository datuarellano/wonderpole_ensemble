/* ======================================================================
  ribbonread() returns a raw reading of the ribbon.
  On the Wonderpole, it's the strips of copper tape that are 
  connected to RIBBON_PIN.
*/
int ribbonRead() {
  return mozziAnalogRead(RIBBON_PIN);
}

/* ======================================================================
  ribbonRemap() reads the ribbon and returns a remapped value
  based on rib_lowest and rib_highest values found in "params.h"
*/
int ribbonRemap(int input) {
  // Read the ribbon
  input = ribbonRead();  
  // Remap the raw ribbon readings
  input = map(input, rib_lowest, rib_highest, 0, rib_mapto_high);
  // Constrain input to numbers between 0 and rib_mapto_high value
  // because there is a possibility of getting -negative values
  return constrain(input, 0, rib_mapto_high);
}

/* ======================================================================
  ribbonMode() returns the current frequency.
  The function contains the call to remap the ribbon,
  the array of ribbon segments,
  the logic to toggle between segmented and non-segmented modes,
  and the logic to assign frequencies to segments.
*/
int ribbonMode() {
  // Run ribbon remap
  int rib_val = ribbonRemap(rib_val);
  
  // Create array of ribbon segments
  int segments[] = {100, 200, 300, 400, 500, 600, 700, 800};

  float octave = pitchKnob();
  int freq;

  // Mode 1 subdivides the ribbon into 8 segments
  if (ribbonmodeSwitch() == 1) 
  {
    if (rib_val < segments[0]) {
      freq = freqs[0] * octave;
    }
    else if (rib_val >= segments[0] && rib_val < segments[1]) {
      freq = freqs[1] * octave;
    }
    else if (rib_val >= segments[1] && rib_val < segments[2]) {
      freq = freqs[2] * octave;
    }
    else if (rib_val >= segments[2] && rib_val < segments[3]) {
      freq = freqs[3] * octave;
    }
    else if (rib_val >= segments[3] && rib_val < segments[4]) {
      freq = freqs[4] * octave;
    }
    else if (rib_val >= segments[4] && rib_val < segments[5]) {
      freq = freqs[5] * octave;
    }
    else if (rib_val >= segments[5] && rib_val < segments[6]) {
      freq = freqs[6] * octave;
    }
    else {
      freq = freqs[7] * octave;
    }
  }
  // Mode 0 is linear and continuous and has no segments/subdivisions
  else if (ribbonmodeSwitch() == 0) 
  {
    // This remaps the frequency range again
    int factor = 4;
    freq = map(rib_val, rib_lowest, rib_highest, freqs[0] * octave, freqs[7] * octave * factor);
  }

  return freq;
}

/* ======================================================================
  ribbon() contains part of the sound design (the other parts are in the
  updateAudio() block in the main .ino file).
  This is where you set:
  1. oscillator frequencies
  2. ADSR settings (attack, decay, sustain, and release values)
  3. envelope times and levels
  4. note on and note off
*/
void ribbon() {
  // Run ribbon mode function to get the current frequency
  int freq = ribbonMode();

  /* --------------
    PRESET 1
    Default is a regular, monophonic sound generated by a single oscillator.
    The Custom switch allows you to toggle between a sine and a 
    sawtooth wave (code is found in updateAudio() block in main .ino file).
  */
  if (presetSwitch() == 1)
  {
    sine0.setFreq(freq);
    saw0.setFreq(freq);
    rib_preset1.attack = 500;
    rib_preset1.decay = 100;
    rib_preset1.sustain = 100;
    rib_preset1.release = 400;
    envelope_rib.setTimes(rib_preset1.attack, rib_preset1.decay, rib_preset1.sustain, rib_preset1.release);
    envelope_rib.setLevels(255, 100, 100, 0);
    if (gateButton() == true)
    {
      envelope_rib.noteOn();
      digitalWrite(LED2_PIN, HIGH);
    }
    else
    {
      envelope_rib.noteOff();
      digitalWrite(LED2_PIN, LOW);
    }
  }

  /* --------------
    PRESET 2
    Default sound is same as Preset 1 except notes 
    are played staccato using an EventDelay timer.
  */
  if (presetSwitch() == 2) 
  {
    int tempo = tempoKnob();
    sine0.setFreq(freq);
    saw0.setFreq(freq);
    rib_preset2.attack = 1;
    rib_preset2.decay = 20;
    rib_preset2.sustain = 20;
    rib_preset2.release = 100;
    envelope_rib.setTimes(rib_preset2.attack, rib_preset2.decay, rib_preset2.sustain, rib_preset2.release);
    envelope_rib.setLevels(255, 255, 255, 0);
    rib_preset2.duration = rib_preset2.attack + rib_preset2.decay + rib_preset2.sustain + rib_preset2.release + tempo; 
    noteDelay.set(rib_preset2.duration);
    if (noteDelay.ready() && gateButton() == true) 
    {
      noteDelay.start(rib_preset2.duration);   
      envelope_rib.noteOn();
      digitalWrite(LED_PIN, LOW);
      digitalWrite(LED2_PIN, HIGH);
    }
    else 
    {
      envelope_rib.noteOff();
      digitalWrite(LED_PIN, HIGH);
      digitalWrite(LED2_PIN, LOW);
    }
  }

  /* --------------
    PRESET 3
    Default sound is a crazy burst of noise.
    The knobs labelled Time, Pitch, and Custom;
    the switch labelled Custom; and the ribbon,
    all have an effect on the sound.
  */
  if (presetSwitch() == 3) 
  {
    int tempo = tempoKnob();
    sine1.setFreq(ribbonRead() * tempo);
    sine2.setFreq(ribbonRead() * 4);
    if (customKnob() > 512)
    {
      int r = rand(1,3);
      saw0.setFreq(freq*r);
      saw1.setFreq(freq*r);
      sine0.setFreq(freq*r);
    }
    else {
      saw0.setFreq(freq/16);
      saw1.setFreq(freq/2);
      sine0.setFreq(freq/16);
    }
    rib_preset3.attack = tempo;
    rib_preset3.decay = 10;
    rib_preset3.sustain = customKnob();
    rib_preset3.release = customKnob();
    envelope_rib.setTimes(rib_preset3.attack, rib_preset3.decay, rib_preset3.sustain, rib_preset3.release);
    if (gateButton() == true) 
    {
      envelope_rib.noteOn();
      digitalWrite(LED2_PIN, HIGH);
      if (customSwitch() == false)
      {
      /* Below is a blocking delay and will cause a nasty glitch effect
      The value of the delay is taken from the ribbon reading */
        delay(ribbonRead()); 
      }
    }
    else 
    {
      envelope_rib.noteOff();
      digitalWrite(LED2_PIN, LOW);
    }
  }
}